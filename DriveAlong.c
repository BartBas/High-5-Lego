#pragma config(Sensor, S1,     color1,         sensorColorNxtFULL)
#pragma config(Sensor, S2,     color2,         sensorColorNxtFULL)
#pragma config(Sensor, S3,     sonar,          sensorSONAR)
#pragma config(Motor,  motorA,          Lookingmotor,  tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorNXT, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(NXT)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

long nLastXmitTimeStamp = nPgmTime;
long nDeltaTime         = 0;

const int kMaxSizeOfMessage = 30;
const int INBOX = 5;

TFileIOResult nBTCmdRdErrorStatus;
int nSizeOfMessage;
ubyte nRcvBuffer[kMaxSizeOfMessage];
string command = "";

task sound(){ // generating tune while active
	while(1==1){
		playTone(10, 2);
		wait1Msec(50);
		playTone(900,2);
		wait10Msec(50);
	}
}
void Sensor()
{
	if (SensorValue[sonar] <24) {
		startTask(sound);
	for(int i = 0; i <= 5; i++)  // initialize int 'i' to 0, and run the loop as long as 'i' is less than 3,
		// incrementing 'i' by 1 after each iteration of the loop
	{
		motor[motorB] = -50 + i*10 ;   // run 'rightMotor' at power level 50
		motor[motorC]  = -50 + i*10;   // run 'leftMotor' at power level 50

	}
}
}

void bluetooth(string &s)
{
	nSizeOfMessage = cCmdMessageGetSize(INBOX);
	if (nSizeOfMessage > kMaxSizeOfMessage)
				nSizeOfMessage = kMaxSizeOfMessage;
	if (nSizeOfMessage > 0){
		nBTCmdRdErrorStatus = cCmdMessageRead(nRcvBuffer, nSizeOfMessage, INBOX);
		nRcvBuffer[nSizeOfMessage] = '\0';
		stringFromChars(s, (char *) nRcvBuffer);
		displayCenteredBigTextLine(5, s);
	}
}

// initialising main task
task main(){
	int black1 = 0, black2 = 0,wacht = 502 *5;
	while(true){
		while(true){
			Sensor();
			switch(SensorValue[color1])
			{
			case BLACKCOLOR: 		motor[motorB]	= +10;  	black1 = 1 ;	break; // if black, stop moving
			case WHITECOLOR:		motor[motorB]	= -50; 	black1 = 0 ; 	break; // if white, start driving
			}
			switch(SensorValue[color2])
			{
			case BLACKCOLOR: 		motor[motorC]	= +10;  	black2 = 1 ;	break; // same as above
			case WHITECOLOR:		motor[motorC]	= -50; 	black2 = 0 ;	break;
			}

			wait1Msec(50);

			if((black1 == 1) && (black2 == 1)){
				int	i=0;
				for(i=0; i<5; i++){
					bluetooth(command);
					if (command == "UP"){
						displayCenteredBigTextLine(2, "OMHOOG");
						motor[motorB] = -50;
						motor[motorC] = -50;
						wait1Msec(wacht);
						command = "";
					}
					if (command == "LEFT"){
						displayCenteredBigTextLine(2, "LEFT");
						motor[motorB] = 10;
						motor[motorC] = -50;
						wait1Msec(30);
						while(true){
						motor[motorB] = -50;
						motor[motorC] = 10;
						if (SensorValue[color2] == BLACKCOLOR)
						{command = "";break;}
						}
						}
					if (command == "RIGHT"){
					  displayCenteredBigTextLine(2, "RIGHT");
						motor[motorB] = -50;
						motor[motorC] = 10;
						wait1Msec(30);
						while(true){
						motor[motorB] = -50;
						motor[motorC] = 10;
						if (SensorValue[color1] == BLACKCOLOR)
						{command = "";break;}
						}
						}
					if (command == "DOWN"){
						displayCenteredBigTextLine(2, "DOWN");
						motor[motorB] = 50;
						motor[motorC] = 50;
						wait1Msec(wacht);
						command = "";
					}
					if (command == ""){
						displayCenteredBigTextLine(2, "no command");
						motor[motorB] = 0;
						motor[motorC] = 0;
					}
				}
			}
		}
	}
}
