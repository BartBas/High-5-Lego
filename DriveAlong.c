#pragma config(Sensor, S1,     color1,         sensorColorNxtFULL)
#pragma config(Sensor, S2,     color2,         sensorColorNxtFULL)
#pragma config(Sensor, S3,     sonar,          sensorSONAR)
#pragma config(Motor,  motorA,          Lookingmotor,  tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorNXT, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(NXT)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

long nLastXmitTimeStamp = nPgmTime;
long nDeltaTime         = 0;

const int kMaxSizeOfMessage = 30; // opzetten van bluetooth data input
const int INBOX = 5;

TFileIOResult nBTCmdRdErrorStatus;
int nSizeOfMessage;
ubyte nRcvBuffer[kMaxSizeOfMessage]; // klaar met opzetten van bluetooth data input
string command = "";  // lege string voor commando's vanaf bluetooth

task sound(){ // generating tune while active
while(0==0){
PlaySoundFile("Epix (1).rso"); // geselecteerde sound voor het afspelen
}
}
void mute(){
stopTask(sound);
ClearSounds();
}
void Unmute(){
startTask(sound);
}

void Motor(int speedB, int speedC){
  if ( speedB == 0 && speedC == 0){
    motor[motorB] = 0
		motor[motorC] = 0;

	}
  else{
    motor[motorB] = speedB;
		motor[motorC] = speedC;
	}
}

void bluetooth(string &s){
	nSizeOfMessage = cCmdMessageGetSize(INBOX);
	if (nSizeOfMessage > kMaxSizeOfMessage)
		nSizeOfMessage = kMaxSizeOfMessage;
	if (nSizeOfMessage > 0){
		nBTCmdRdErrorStatus = cCmdMessageRead(nRcvBuffer, nSizeOfMessage, INBOX);
		nRcvBuffer[nSizeOfMessage] = '\0';
		stringFromChars(s, (char *) nRcvBuffer);
		displayCenteredBigTextLine(5, s);
	}
}

/*
void Sensor()
{
	if (SensorValue[sonar] <24) {
		startTask(sound);
		for(int i = 0; i <= 5; i++)  // initialize int 'i' to 0, and run the loop as long as 'i' is less than 3,
			// incrementing 'i' by 1 after each iteration of the loop
		{
			motor[motorB] = -50 + i*10 ;   // run 'rightMotor' at power level 50
			motor[motorC]  = -50 + i*10;   // run 'leftMotor' at power level 50
			wait1Msec(10);
		}
	}
	stopTask(sound);
}
*/
void up(){
	while(SensorValue[color2] == BLACKCOLOR || SensorValue[color1] == BLACKCOLOR){	//zolang een van de 2 sensoren zwart ziet gaat het voertuig vooruit, beide wit gaan we verder met de normale code
	  Motor(50,50);
  }
}

void right(){
	int state = 0;
  Motor(50,50);
	wait1Msec(50); 	// Korte delay zodat hij eerst een stukje naar achter rijdt
	Motor(-10,50);
	while(true){
		if (state == 0){ // state manier om te kijken hoever in de bocht je zit
			if (SensorValue[color1] == WHITECOLOR){ state = 1; displayCenteredBigTextLine(2, "1");}
		}
		if (state == 1){
			if (SensorValue[color1] == BLACKCOLOR){ state = 2; displayCenteredBigTextLine(2, "2");}
		}
		if (state == 2){ displayCenteredBigTextLine(2, "over"); break;}

	}
}

void left(){
	int state = 0;
	displayCenteredBigTextLine(2, "LEFT");
	Motor(50,50);
	wait1Msec(50);
	Motor(50,-10);
	while(true){
		if (state == 0){
			if (SensorValue[color2] == WHITECOLOR){ state = 1; displayCenteredBigTextLine(2, "1");}
		}
		if (state == 1){
			if (SensorValue[color2] == BLACKCOLOR){ state = 2; displayCenteredBigTextLine(2, "2");}
		}
		if (state == 2){ displayCenteredBigTextLine(2, "over"); break;}

	}
}

void down(){
	int state = 0;
 	Motor(-50,-50);
	wait1Msec(200);
	Motor(-50,50);
	while(true){
		if (state == 0){
			if (SensorValue[color2] == BLACKCOLOR){ state = 1; displayCenteredBigTextLine(2, "1");}
		}
		if (state == 1){
			if (SensorValue[color2] == WHITECOLOR){ state = 2; displayCenteredBigTextLine(2, "2");}
    }
    if (state == 2){
			if (SensorValue[color2] == BLACKCOLOR){ state = 3; displayCenteredBigTextLine(2, "3");}
		}
		if (state == 3){ displayCenteredBigTextLine(2, "over"); break;}
	}
}

void stop(){
Motor(0,0);
  while(true){
  bluetooth(command);
  if(command == "UP"){
  	Unmute();
    break;
    }
    if(command == "DOWN"){
    Unmute();
    down();
    break;
    }
  }
}

// initialising main task
task main(){
	starttask(sound);
	Unmute();
	int black1 = 0, black2 = 0, state = 0;
	while(true){
		while(true){
      bluetooth(command);
			//Sensor();
			state = 0;
			switch(SensorValue[color1]){
			case BLACKCOLOR:  motor[motorB] = -10; black1 = 1 ; break; // if black, stop moving
			case WHITECOLOR:  motor[motorB] = 50;  black1 = 0 ; break; // if white, start driving
			}
      
			switch(SensorValue[color2]){
			case BLACKCOLOR:  motor[motorC] = -10;	black2 = 1 ; break; // same as above
			case WHITECOLOR:  motor[motorC] = 50;  	black2 = 0 ; break;
			}
      
      if (command == "FIRE"){	//stopt het voertuig
				mute();
        stop();
      	command = "";
      }
      
      

			wait1Msec(50);	// delay zodat de loop maar 20 keer per seconde wordt aangehaald
			if((black1 == 1) && (black2 == 1)){	//Als beide motoren zwart geven gaan de motoren op '0' (het voertuig stopt) zodat er tijd is om input tegeven
				mute();
				Motor(0,0);				
				int i=0;
				for(i=0; i<5; i++){
					bluetooth(command);
					if (command == "UP"){
						displayCenteredBigTextLine(2, "OMHOOG");
						Unmute();
						up();
						command = "";
					}
					if (command == "LEFT"){
            displayCenteredBigTextLine(2, "LEFT");
						Unmute();
						left();
						command = "";
					}
					if (command == "RIGHT"){
						displayCenteredBigTextLine(2, "RIGHT");
						Unmute();
						right();
						command = "";
					}
					if (command == "DOWN"){
						displayCenteredBigTextLine(2, "DOWN");
						Unmute();
						down();
						command = "";
					}
				}
			}
		if (command == ""){
			displayCenteredBigTextLine(2, "GEEN");
      displayCenteredBigTextLine(5, "INPUT");
		}
		}		
	}
}
