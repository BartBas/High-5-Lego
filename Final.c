#pragma config(Sensor, S1,     color1,         sensorColorNxtFULL)
#pragma config(Sensor, S2,     color2,         sensorColorNxtFULL)
#pragma config(Sensor, S3,     sonar,          sensorSONAR)
#pragma config(Motor,  motorA,          Lookingmotor,  tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorNXT, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(NXT)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


long nLastXmitTimeStamp = nPgmTime;
long nDeltaTime         = 0;

const int kMaxSizeOfMessage = 30; // opzetten van bluetooth data input
const int INBOX = 5;

TFileIOResult nBTCmdRdErrorStatus;
int nSizeOfMessage;
ubyte nRcvBuffer[kMaxSizeOfMessage]; // klaar met opzetten van bluetooth data input
string command = "";  // lege string voor commando's vanaf bluetooth


int force_stop = 0, black1 = 0, black2 = 0; //  integers for driving
int Xb = 1,	Yb = 0,	pos=1;   // where are and our facing.  1 = X+  2 = X-  3 = Y+ 4 = Y-
int Xe = 3, Ye = 2; // where do you wana go
int versie;
task sound(){ 	// generating tune while active
	while(0==0){
		playSoundFile("Epix (1).rso"); // geselecteerde sound voor het afspelen
	}
}

void follow_line(){ // let the robot follow the line
	switch(SensorValue[color1]){
	case BLACKCOLOR:  motor[motorB] = -10; black1 = 1 ; break; // if black, stop moving
	case WHITECOLOR:  motor[motorB] = 50;  black1 = 0 ; break; // if white, start driving
	}

	switch(SensorValue[color2]){
	case BLACKCOLOR:  motor[motorC] = -10;	black2 = 1 ; break; // same as above
	case WHITECOLOR:  motor[motorC] = 50;  	black2 = 0 ; break;
	}
}

void follow_line_slow(){ // let the robot follow the line slowly
	switch(SensorValue[color1]){
	case BLACKCOLOR:  motor[motorB] = -5; black1 = 1 ; break; // if black, stop moving
	case WHITECOLOR:  motor[motorB] = 25; black1 = 0 ; break; // if white, start driving
	}

	switch(SensorValue[color2]){
	case BLACKCOLOR:  motor[motorC] = -5;	black2 = 1 ; break; // same as above
	case WHITECOLOR:  motor[motorC] = 25; black2 = 0 ; break;
	}
}

void mute(){ // stops the music
	stopTask(sound);
	clearSounds();
}

void Unmute(){ // restarts the music
	startTask(sound);
}

void Motor(int speedB, int speedC){ // controls the motor
	if ( speedB == 0 && speedC == 0){
		motor[motorB] = 0;
		motor[motorC] = 0;
		mute();

	}
	else{
		motor[motorB] = speedB;
		motor[motorC] = speedC;
	}
}

void bluetooth(string &s){ // creates Input
	nSizeOfMessage = cCmdMessageGetSize(INBOX);
	if (nSizeOfMessage > kMaxSizeOfMessage)
		nSizeOfMessage = kMaxSizeOfMessage;
	if (nSizeOfMessage > 0){
		nBTCmdRdErrorStatus = cCmdMessageRead(nRcvBuffer, nSizeOfMessage, INBOX);
		nRcvBuffer[nSizeOfMessage] = '\0';
		stringFromChars(s, (char *) nRcvBuffer);
		displayCenteredBigTextLine(5, s);
	}
}

void up(){ // drives along
	Unmute();
	while(SensorValue[color2] == BLACKCOLOR || SensorValue[color1] == BLACKCOLOR){	//zolang een van de 2 sensoren zwart ziet gaat het voertuig vooruit, beide wit gaan we verder met de normale code
		Motor(50,50);
	}
}

void right(){ // turn right
	Unmute();
	int state = 0;
	Motor(50,50);
	wait1Msec(50); 	// Korte delay zodat hij eerst een stukje naar achter rijdt
	Motor(-10,50);
	while(true){
		bluetooth(command);
		if (state == 0){ // state manier om te kijken hoever in de bocht je zit, ook gebruikt in left en down
			if (SensorValue[color1] == WHITECOLOR){ state = 1; displayCenteredBigTextLine(2, "1");}
		}
		if (state == 1){
			if (SensorValue[color1] == BLACKCOLOR){ state = 2; displayCenteredBigTextLine(2, "2");}
		}
		if (state == 2){ displayCenteredBigTextLine(2, "over"); break;}
		if (command == "FIRE") {
			break;}
	}
}

void left(){ // turn left
	Unmute();
	int state = 0;
	displayCenteredBigTextLine(2, "LEFT");
	Motor(50,50);
	wait1Msec(50);
	Motor(50,-10);
	while(true){
		bluetooth(command);
		if (state == 0){
			if (SensorValue[color2] == WHITECOLOR){ state = 1; displayCenteredBigTextLine(2, "1");}
		}
		if (state == 1){
			if (SensorValue[color2] == BLACKCOLOR){ state = 2; displayCenteredBigTextLine(2, "2");}
		}
		if (state == 2){ displayCenteredBigTextLine(2, "over"); break;}
		if (command == "FIRE") {
			force_stop = 1;
			break;}

	}
}

void down(){ // turns around
	Unmute();
	int state = 0;
	Motor(-50,-50);
	wait1Msec(200);
	Motor(-50,50);
	while(true){
		bluetooth(command);
		if (state == 0){
			if (SensorValue[color2] == BLACKCOLOR){ state = 1; displayCenteredBigTextLine(2, "1");}
		}
		if (state == 1){
			if (SensorValue[color2] == WHITECOLOR){ state = 2; displayCenteredBigTextLine(2, "2");}
		}
		if (state == 2){
			if (SensorValue[color2] == BLACKCOLOR){ state = 3; displayCenteredBigTextLine(2, "3");}
		}
		if (state == 3){ displayCenteredBigTextLine(2, "over"); break;}
		if (command == "FIRE") {
			break;}
	}
}

void stop(){ // stops the robot
	Motor(0,0);
	while(true){
		bluetooth(command);
		if(command == "UP"){
			Unmute();
			break;
		}
		if (versie == 1){
			if(command == "DOWN"){
				down();
				Unmute();
				break;
			}
		}

	}
}

void Sensor(){ // checks the Sensor for obsticles
	if(SensorValue[sonar] < 27){
		int a = 0;
		while (true){
			command = "";
			bluetooth(command);
			if (a == 1) {
				while (true){
					command = "";
					bluetooth(command);
					if (command == "DOWN") {
						down();
						a = 2;
						break;
					}
					if (command == "LEFT") {
						left();
						a = 2;
						break;
					}
					if (command == "RIGHT") {
						right();
						a = 2;
						break;
					}
				}
			}
			if (a == 2) { break ;}

			if (SensorValue[sonar] >27) {
				break;
			}
			if (SensorValue[sonar] <=26 && SensorValue[sonar] > 22) {
				follow_line_slow();
			}
			if (SensorValue[sonar] <=22){
				mute();
				Motor(0,0);
				displayCenteredBigTextLine(2, "OBSTAKEL");
				displayCenteredBigTextLine(5, "EVADE");
				a = 1;
			}

			if (command == "FIRE") {
				force_stop = 1;
				break;
			}
		}
	}
}

void route(){ // makes the robot drive to its destination
	Unmute();
	if (Xb != Xe){
		if (Xb < Xe && pos == 1){up();pos = 1; Xb++;}							// it wants X to expant
		else if (Xb < Xe && pos == 2){down();pos = 1; Xb++;}
		else if (Xb < Xe && pos == 3){right();pos = 1; Xb++;}
		else if (Xb < Xe && pos == 4){left();pos = 1; Xb++;}

		else if (Xb > Xe && pos == 1){down();pos = 2; Xb--;} 			// it wants X to shrink
		else if (Xb > Xe && pos == 2){up();pos = 2; Xb--;}
		else if (Xb > Xe && pos == 3){left();pos = 2; Xb--;}
		else if (Xb > Xe && pos == 4){right();pos = 2; Xb--;}
	}
	else{
		if (Yb != Ye){																// it wants Y to expant
			if (Yb < Ye && pos == 4){down();pos = 3; Yb++;}
			else if (Yb < Ye && pos == 3 ){up();pos = 3; Yb++;}
			else if (Yb < Ye && pos == 2 ){right();pos = 3; Yb++;}
			else if (Yb < Ye && pos == 1 ){left();pos = 3; Yb++;}

			else if (Yb > Ye && pos == 4 ){up();pos = 4; Yb--;}				// it wants Y to shrink
			else if (Yb > Ye && pos == 3 ){down();pos = 4; Yb--;}
			else if (Yb > Ye && pos == 2 ){left();pos = 4; Yb--;}
			else if (Yb > Ye && pos == 1 ){right();pos = 4; Yb--;}
		}
		if (Yb == Ye && Xb == Xe) {
			bluetooth(command);
			displayCenteredBigTextLine(2, "LOCATIE");
			displayCenteredBigTextLine(5, "BEREIKT");
			Motor(0,0);
		}
	}
}

void menu(){ // Setup your position and destination
	eraseDisplay();
	Xe = 0;Ye = 0;
	while(1==1){ // Setup Begin value
		bluetooth(command);
		nxtDisplayCenteredTextLine(1, "Where am I right now?");
		nxtDisplayCenteredTextLine(3, "X %d, Y %d", Xb, Yb);
		if (command == "UP"){
			Yb ++;
			command = "";
		}
		if (command == "DOWN"){
			Yb --;
			command = "";
		}
		if (command == "RIGHT"){
			Xb ++;
			command = "";
		}
		if (command == "LEFT"){
			Xb --;
			command = "";
		}
		if (command == "FIRE"){
			command = "";
			break;
		}
		wait1Msec(100);
	}

	while(1==1){ // setup destination
		bluetooth(command);
		//nxtDisplayCenteredTextLine(1, "Here I Am");
		//nxtDisplayCenteredTextLine(3, "%d, %d", Xb, Yb);
		nxtDisplayCenteredTextLine(1, "Where do I want to go");
		nxtDisplayCenteredTextLine(3, "X %d, Y %d", Xe, Ye);
		if (command == "UP"){
			Ye ++;
			command = "";
		}
		if (command == "DOWN"){
			Ye --;
			command = "";
		}
		if (command == "RIGHT"){
			Xe ++;
			command = "";
		}
		if (command == "LEFT"){
			Xe --;
			command = "";
		}
		if (command == "FIRE"){
			command = "";
			break;
		}
		wait1Msec(100);
	}

	while (1==1){ // setup position
		bluetooth(command);
		nxtDisplayCenteredTextLine(1, "Where am i facing");
		if (pos == 1){
			nxtDisplayCenteredTextLine(3, "East",);
		}
		if (pos == 2){
			nxtDisplayCenteredTextLine(3, "West",);
		}
		if (pos == 3){
			nxtDisplayCenteredTextLine(3, "North",);
		}
		if (pos == 4){
			nxtDisplayCenteredTextLine(3, "South",);
		}
		if (command == "UP"){
			pos = 3;
			command = "";
		}
		if (command == "DOWN"){
			pos = 4;
			command = "";
		}
		if (command == "LEFT"){
			pos = 2;
			command = "";
		}
		if (command == "RIGHT"){
			pos = 1;
			command = "";
		}
		if (command == "FIRE"){
			command = "";
			break;
		}
		wait1Msec(100);
	}
}
int question(){ // wana follow a line or drive along a Grid?
	int awnser = 1;
	while(true)	{
		while (true){
			bluetooth(command);
			nxtDisplayCenteredTextLine(1, "What should I do?");
			if (awnser == 1){
				nxtDisplayCenteredTextLine(3, "Follow a line",);
			}
			if (awnser == 2){
				nxtDisplayCenteredTextLine(3, "Ride a grid",);
			}
			if (command == "UP"){
				awnser--;
				command = "";
			}
			if (command == "DOWN"){
				awnser++;
				command = "";
			}
			if (awnser == 0){
				awnser = 2;
			}
			if (awnser == 3){
				awnser = 1;
			}
			if (command == "FIRE"){
				command = "";
				break;
			}
			wait1Msec(100);
		}
		if (awnser != 0){break;}
	}
	return (awnser);
}

task main(){	// initialising main task
	versie = question();
	if (versie == 2){menu();}
	startTask(sound);
	Unmute();
	while(true){
		while(true){
			Unmute();
			bluetooth(command);
			Sensor();
			follow_line();

			if (command == "FIRE" || force_stop == 1){	//stopt het voertuig
				force_stop = 0;
				mute();
				stop();
				command = "";
			}



			wait1Msec(50);	// delay zodat de loop maar 20 keer per seconde wordt aangehaald
			if((black1 == 1) && (black2 == 1)){	//Als beide motoren zwart geven gaan de motoren op '0' (het voertuig stopt) zodat er tijd is om input tegeven
				mute();
				Motor(0,0);
				if (versie == 1){
					int i=0;
					for(i=0; i<5; i++){
						bluetooth(command);
						if (command == "UP"){
							displayCenteredBigTextLine(2, "OMHOOG");
							Unmute();
							up();
							command = "";
						}
						if (command == "LEFT"){
							displayCenteredBigTextLine(2, "LEFT");
							Unmute();
							left();
							command = "";
						}
						if (command == "RIGHT"){
							displayCenteredBigTextLine(2, "RIGHT");
							Unmute();
							right();
							command = "";
						}
						if (command == "DOWN"){
							displayCenteredBigTextLine(2, "DOWN");
							Unmute();
							down();
							command = "";
						}
					}
				}
				if(versie ==2){
					route();
				}

			}
		}
	}
}