#pragma config(Sensor, S1,     color1,         sensorColorNxtFULL)
#pragma config(Sensor, S2,     color2,         sensorColorNxtFULL)
#pragma config(Motor,  motorA,          Lookingmotor,  tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          leftMotor,    tmotorNXT, openLoop, encoder) // links
#pragma config(Motor,  motorC,          rightMotor,     tmotorNXT, openLoop, encoder)// rechts
#pragma platform(NXT)

long nLastXmitTimeStamp = nPgmTime;
long nDeltaTime         = 0;

const int kMaxSizeOfMessage = 30;
const int INBOX = 5;
string s = "";
string k = "";
  //*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
task sound(){
	// generating tune while active
	while(1==1){
			playTone(10, 2);
	    wait1Msec(50);
	    playTone(900,2);
	    wait10Msec(50);
	}
}

task bluetooth()
{
	while(true)
  {
    // Check to see if a message is available

 		TFileIOResult nBTCmdRdErrorStatus;
		int nSizeOfMessage;
		ubyte nRcvBuffer[kMaxSizeOfMessage];
    nSizeOfMessage = cCmdMessageGetSize(INBOX);

    if (nSizeOfMessage > kMaxSizeOfMessage){
      nSizeOfMessage = kMaxSizeOfMessage;}
    if (nSizeOfMessage > 0){
    	nBTCmdRdErrorStatus = cCmdMessageRead(nRcvBuffer, nSizeOfMessage, INBOX);
    	nRcvBuffer[nSizeOfMessage] = '\0';
    	string s = "";
    	stringFromChars(s, (char *) nRcvBuffer);
    	displayCenteredBigTextLine(5, s);
    	string k = s;
    	if (s == "UP"){
    		displayCenteredBigTextLine(2, s);
    		motor[motorB] = -50;
    		motor[motorC] = -50;
    		displayCenteredBigTextLine(2, "go");
    		wait1Msec(3000);
    		break;}
    	else {
    		displayCenteredBigTextLine(2, "");
    		}
    	}

  }
  return ;
}

// initialising main task
task main()
{
	int black1 = 0;
	int black2 = 0;
	while(true)
		{

		switch(SensorValue[color1])
		{
			case BLACKCOLOR: 		motor[motorB]	= 0;  	black1 = 1 ;	break; // if black, stop moving
			case WHITECOLOR:		motor[motorB]	= -50; 	black1 = 0 ; 	break; // if white, start driving
		}

		switch(SensorValue[color2])
		{
			case BLACKCOLOR: 		motor[motorC]	= 0;  	black2 = 1 ;	break; // same as above
			case WHITECOLOR:		motor[motorC]	= -50; 	black2 = 0 ;	break;
		}

//		string k = getBluetoothMessage();


		if((black1 == 1) && (black2 == 1)){
			startTask(bluetooth);

		}

	}
	// end
	stopAllMotors();
}

// bluetooth via variable seperate path (synchron task)
// bluetooth via seperate while loop (set path)
